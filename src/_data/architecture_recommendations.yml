# ia-translate: true
- category: Separação de responsabilidades
  description: |
    Você deve separar seu app em uma camada de UI e uma camada de dados. Dentro dessas camadas, você deve separar ainda mais a lógica em classes por responsabilidade.
  recommendations:
    - recommendation: Use camadas de dados e UI claramente definidas.
      description: |
        Separação de responsabilidades é o princípio arquitetural mais importante.
        A camada de dados expõe os dados da aplicação para o resto do app e contém a maior parte da lógica de negócio em sua aplicação.
        A camada de UI exibe os dados da aplicação e escuta eventos de usuários. A camada de UI contém classes separadas para lógica de UI e widgets.
      confidence: strong

    - recommendation: Use o repository pattern na camada de dados.
      description: |
        O repository pattern é um padrão de design de software que isola a lógica de acesso a dados do resto da aplicação.
        Ele cria uma camada de abstração entre a lógica de negócio da aplicação e os mecanismos de armazenamento de dados subjacentes (bancos de dados, APIs, sistemas de arquivos, etc.).
        Na prática, isso significa criar classes Repository e classes Service.
      confidence: strong

    - recommendation: Use ViewModels e Views na camada de UI. (MVVM)
      description: |
        Separação de responsabilidades é o princípio arquitetural mais importante.
        Esta separação em particular torna seu código muito menos propenso a erros porque seus widgets permanecem "burros".
      confidence: strong

    - recommendation: Use `ChangeNotifiers` e `Listenables` para lidar com atualizações de widgets.
      description: |
        A API `ChangeNotifier` faz parte do Flutter SDK e é uma maneira conveniente de fazer seus widgets observarem mudanças em seus ViewModels.
      confidence: conditional
      confidence-description: |
        Existem muitas opções para lidar com gerenciamento de estado, e no final a decisão se resume à preferência pessoal.
        Leia sobre [nossa recomendação de ChangeNotifier][our ChangeNotifier recommendation] ou [outras opções populares][other popular options].

    - recommendation: Não coloque lógica em widgets.
      description: |
        A lógica deve ser encapsulada em métodos no ViewModel. A única lógica que uma view deve conter é:
        * Declarações if simples para mostrar e ocultar widgets com base em uma flag ou campo nullable no ViewModel
        * Lógica de animação que depende do widget para calcular
        * Lógica de layout baseada em informações do dispositivo, como tamanho da tela ou orientação.
        * Lógica de roteamento simples
      confidence: strong

    - recommendation: Use uma camada de domínio.
      description: |
        Uma camada de domínio só é necessária se sua aplicação tiver lógica extremamente complexa que sobrecarrega seus ViewModels,
        ou se você se encontrar repetindo lógica em ViewModels.
        Em apps muito grandes, use-cases são úteis, mas na maioria dos apps eles adicionam overhead desnecessário.
      confidence: conditional
      confidence-description: |
        Use em apps com requisitos de lógica complexa.

- category: Manipulação de dados
  description: |
    Manipular dados com cuidado torna seu código mais fácil de entender, menos propenso a erros e
    previne que dados malformados ou inesperados sejam criados.
  recommendations:
    - recommendation: Use fluxo de dados unidirecional.
      description: |
        Atualizações de dados devem fluir apenas da camada de dados para a camada de UI.
        Interações na camada de UI são enviadas para a camada de dados onde são processadas.
      confidence: strong

    - recommendation: Use `Commands` para lidar com eventos de interação do usuário.
      description: |
        Commands previnem erros de renderização em seu app e padronizam como a camada de UI envia eventos para a camada de dados.
        Leia sobre commands no [estudo de caso de arquitetura][architecture case study].
      confidence: recommend

    - recommendation: Use modelos de dados imutáveis.
      description: |
        Dados imutáveis são cruciais para garantir que os dados sejam atualizados apenas no modelo.
      confidence: strong

    - recommendation: Use freezed ou built_value para gerar modelos de dados imutáveis.
      description: |
        Você pode usar pacotes para ajudar a gerar funcionalidades úteis em seus modelos de dados, [freezed][] ou [built_value][].
        Estes podem gerar métodos de modelo comuns como serialização/desserialização JSON, verificação de igualdade profunda e métodos de cópia.
        Esses pacotes de geração de código podem adicionar tempo de compilação significativo às suas aplicações se você tiver muitos modelos.
      confidence: recommend

    - recommendation: Crie modelos de API e modelos de domínio separados.
      description: |
        Usar modelos separados adiciona verbosidade, mas previne complexidade em ViewModels e use-cases.
      confidence: conditional
      confidence-description: Use em apps grandes.

- category: Estrutura do app
  description: |
    Código bem organizado beneficia tanto a saúde do app em si quanto a equipe trabalhando no código.
  recommendations:

    - recommendation: Use injeção de dependência.
      description: |
        Injeção de dependência previne que seu app tenha objetos globalmente acessíveis, o que torna seu código menos propenso a erros.
        Recomendamos que você use o pacote [provider](https://pub.dev/packages/provider) para lidar com injeção de dependência.
      confidence: strong

    - recommendation: Use [go_router](https://pub.dev/packages/go_router) para navegação.
      description: |
        Go_router é a maneira preferida de escrever 90% das aplicações Flutter.
        Existem alguns casos de uso específicos que go_router não resolve,
        nos quais você pode usar a [API Navigator do Flutter][Flutter Navigator API] diretamente ou experimentar outros pacotes encontrados em [pub.dev][].
      confidence: recommend

    - recommendation: Use convenções de nomenclatura padronizadas para classes, arquivos e diretórios.
      description: |
        Recomendamos nomear classes pelo componente arquitetural que elas representam.
        Por exemplo, você pode ter as seguintes classes:

        * HomeViewModel
        * HomeScreen
        * UserRepository
        * ClientApiService

        Para maior clareza, não recomendamos usar nomes que possam ser confundidos com objetos do Flutter SDK.
        Por exemplo, você deve colocar seus widgets compartilhados em um diretório chamado `ui/core/`,
        em vez de um diretório chamado `/widgets`.
      confidence: recommend

    - recommendation: Use classes de repository abstratas
      description: |
        Classes de repository são as fontes de verdade para todos os dados em seu app,
        e facilitam a comunicação com APIs externas.
        Criar classes de repository abstratas permite que você crie diferentes implementações,
        que podem ser usadas para diferentes ambientes do app, como "development" e "staging".
      confidence: strong

- category: Testes
  description: |
    Boas práticas de testes tornam seu app flexível.
    Também tornam simples e de baixo risco adicionar nova lógica e nova UI.
  recommendations:

    - recommendation: Teste componentes arquiteturais separadamente e em conjunto.
      description: |
        * Escreva testes unitários para cada classe de service, repository e ViewModel. Esses testes devem testar a lógica de cada método individualmente.
        * Escreva testes de widget para views. Testar roteamento e injeção de dependência são particularmente importantes.
      confidence: strong

    - recommendation: Crie fakes para testes (e escreva código que aproveite os fakes.)
      description: |
       Fakes não estão preocupados com o funcionamento interno de qualquer método em particular tanto quanto
       estão preocupados com entradas e saídas. Se você tem isso em mente ao escrever código de aplicação,
       você é forçado a escrever funções e classes modulares e leves com entradas e saídas bem definidas.
      confidence: strong
